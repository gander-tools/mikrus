name: "ü¶ï Deno AI Issue Auto-Tagger"

on:
  issues:
    types: [opened, edited]

permissions:
  issues: write
  contents: read

jobs:
  deno-auto-tag-issues:
    name: "ü¶ï Deno Analyze and Tag Issues"
    runs-on: ubuntu-latest
    if: github.repository == 'gander-tools/mikrus'

    steps:
      - name: "üîç Analyze Issue Content"
        id: deno_issue_analyze
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = issue.body ? issue.body.toLowerCase() : '';
            
            console.log('Issue Title:', issue.title);
            console.log('Issue Body Length:', issue.body ? issue.body.length : 0);
            
            // Initialize labels array
            let labels = [];
            
            // Primary categorization based on title prefix and content
            if (title.includes('[feature]') || title.includes('feature request')) {
              labels.push('feature');
              console.log('‚úÖ Detected FEATURE request');
            } else if (title.includes('[bug]') || title.includes('bug report')) {
              labels.push('bug');
              console.log('‚úÖ Detected BUG report');
            }
            
            // Content-based analysis for additional context
            const contentKeywords = {
              // Priority indicators
              'critical': () => labels.push('priority:critical'),
              'urgent': () => labels.push('priority:high'),
              'blocking': () => labels.push('priority:high'),
              'important': () => labels.push('priority:medium'),
              
              // Component areas
              'cli': () => labels.push('area:cli'),
              'command': () => labels.push('area:cli'),
              'generate': () => labels.push('area:generation'),
              'template': () => labels.push('area:generation'),
              'configuration': () => labels.push('area:config'),
              'config': () => labels.push('area:config'),
              'documentation': () => labels.push('area:docs'),
              'readme': () => labels.push('area:docs'),
              'security': () => labels.push('area:security'),
              'performance': () => labels.push('area:performance'),
              'slow': () => labels.push('area:performance'),
              
              // Bug types
              'crash': () => labels.push('type:crash'),
              'error': () => labels.push('type:error'),
              'exception': () => labels.push('type:error'),
              'memory leak': () => labels.push('type:memory'),
              'regression': () => labels.push('type:regression'),
              
              // Feature types
              'enhancement': () => labels.push('type:enhancement'),
              'improvement': () => labels.push('type:enhancement'),
              'new command': () => labels.push('type:new-feature'),
              'api': () => labels.push('area:api'),
              
              // Complexity indicators
              'simple': () => labels.push('complexity:low'),
              'complex': () => labels.push('complexity:high'),
              'breaking change': () => labels.push('breaking-change'),
              'backward compatibility': () => labels.push('breaking-change'),
              
              // Platform specific
              'windows': () => labels.push('platform:windows'),
              'macos': () => labels.push('platform:macos'),
              'linux': () => labels.push('platform:linux'),
              'node': () => labels.push('runtime:node'),
              'bun': () => labels.push('runtime:bun'),
            };
            
            // Analyze content for keywords
            const fullContent = `${title} ${body}`;
            for (const [keyword, action] of Object.entries(contentKeywords)) {
              if (fullContent.includes(keyword)) {
                action();
                console.log(`üîç Found keyword: "${keyword}"`);
              }
            }
            
            // Special detection patterns
            if (body.includes('steps to reproduce') || body.includes('reproduction')) {
              labels.push('needs-reproduction');
              console.log('üìù Found reproduction steps');
            }
            
            if (body.includes('workaround') && !body.includes('no workaround')) {
              labels.push('has-workaround');
              console.log('üîß Found workaround mentioned');
            }
            
            // Environment detection
            if (body.includes('environment') || body.includes('version')) {
              labels.push('has-environment-info');
              console.log('üñ•Ô∏è Found environment information');
            }
            
            // Remove duplicates and return
            labels = [...new Set(labels)];
            console.log('Final labels:', labels);
            
            return {
              labels: labels,
              shouldTag: labels.length > 0
            };

      - name: "üè∑Ô∏è Apply Labels to Issue"
        id: deno_issue_apply_labels
        if: fromJSON(steps.deno_issue_analyze.outputs.result).shouldTag
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
        with:
          script: |
            const result = JSON.parse('${{ steps.deno_issue_analyze.outputs.result }}');
            const suggestedLabels = result.labels;
            
            if (suggestedLabels.length === 0) {
              console.log('‚ùå No labels to apply');
              return;
            }
            
            console.log(`üè∑Ô∏è Processing ${suggestedLabels.length} suggested labels:`, suggestedLabels);
            
            try {
              // Check which labels exist in the repository
              const existingLabelsResponse = await github.rest.issues.listLabelsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              
              const existingLabelNames = existingLabelsResponse.data.map(label => label.name);
              console.log(`üìã Repository has ${existingLabelNames.length} existing labels`);
              
              // Filter to only apply labels that exist
              const validLabels = suggestedLabels.filter(label => existingLabelNames.includes(label));
              const missingLabels = suggestedLabels.filter(label => !existingLabelNames.includes(label));
              
              console.log(`‚úÖ Valid labels to apply (${validLabels.length}):`, validLabels);
              if (missingLabels.length > 0) {
                console.log(`‚ö†Ô∏è  Missing labels that need to be created (${missingLabels.length}):`, missingLabels);
              }
              
              // Apply only existing labels
              if (validLabels.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: validLabels
                });
                
                console.log(`‚úÖ Successfully applied ${validLabels.length} labels`);
              } else {
                console.log('‚ö†Ô∏è No valid labels to apply - all suggested labels are missing from repository');
              }
              
              // Add a comment explaining the auto-tagging results
              const appliedLabelsText = validLabels.length > 0 ? 
                'This issue has been automatically analyzed and tagged with the following labels:\n' + 
                validLabels.map(label => `- \`${label}\``).join('\n') : 
                'This issue was analyzed but no existing labels matched the content.';
              
              const missingLabelsText = missingLabels.length > 0 ? 
                '\n\n**Note**: The following labels were suggested but don\'t exist in this repository yet:\n' +
                missingLabels.map(label => `- \`${label}\``).join('\n') + 
                '\n\nMaintainers may want to create these labels for better issue organization.' : '';
              
              const comment = 'ü§ñ **Auto-Tagging Complete**\n\n' +
                appliedLabelsText + missingLabelsText + '\n\n' +
                'These labels help organize and prioritize issues. If any labels seem incorrect, maintainers can adjust them manually.\n\n' +
                '---\n' +
                '*This is an automated process. For questions about auto-tagging, please check the [workflow documentation](https://github.com/' +
                context.repo.owner + '/' + context.repo.repo + '/blob/main/.github/workflows/issue-auto-tagger.yml).*';

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
              
            } catch (error) {
              console.error('‚ùå Error applying labels:', error);
              core.setFailed(`Failed to apply labels: ${error.message}`);
            }

      - name: "üìä Issue Triage Summary"
        id: deno_issue_triage_summary
        if: always()
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
        with:
          script: |
            const issue = context.payload.issue;
            const analyzeResult = '${{ steps.deno_issue_analyze.outputs.result }}';
            const result = analyzeResult ? JSON.parse(analyzeResult) : {};
            
            console.log('=== ISSUE TRIAGE SUMMARY ===');
            console.log(`Issue #${issue.number}: ${issue.title}`);
            console.log(`Author: ${issue.user.login}`);
            console.log(`Labels Applied: ${result.labels ? result.labels.join(', ') : 'none'}`);
            console.log(`Auto-tagging: ${result.shouldTag ? 'SUCCESS' : 'SKIPPED'}`);
            console.log('============================');
