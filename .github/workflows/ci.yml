name: "🚀 CI/CD Pipeline"

# Main continuous integration workflow for code quality and testing
# Triggers: Push/PR to main+develop branches + manual dispatch
# Jobs: lint-and-format → test → build → [security-audits] → integration-test → notify

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  lint-and-format:
    name: "✨ Code Quality: Lint & Format"
    # Runs Biome checks, validates pre-commit hooks (lefthook), caches build outputs
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: "📥 Repository: Checkout Code"
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - name: "⚡ Runtime: Setup Bun Environment"
        uses: oven-sh/setup-bun@f4d14e03ff726c06358e5557344e1da148b56cf7 # v1
        with:
          bun-version: latest

      - name: "💾 Cache: Restore Dependencies"
        uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809 # v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: "📦 Dependencies: Install Frozen Lockfile"
        # Installs exact dependencies from lockfile for reproducible builds
        run: bun install --frozen-lockfile

      - name: "🛣️ Environment: Add CLI Tools to PATH"
        # Makes node_modules/.bin tools available for subsequent steps
        run: echo "./node_modules/.bin" >> $GITHUB_PATH

      - name: "✨ Code Quality: Biome Lint & Format Check"
        # Validates code style, formatting, and linting rules using Biome
        run: bunx @biomejs/biome ci

      - name: "✅ Validation: Pre-commit Hooks Check"
        run: |
          if [ -f ".lefthook.yml" ] || [ -f "lefthook.yml" ]; then
            echo "✅ Lefthook configuration found"
            bunx lefthook install
            bunx lefthook run pre-commit --all-files || echo "⚠️ Pre-commit hooks failed"
          else
            echo "ℹ️ No pre-commit hooks configured"
          fi

      - name: "🧹 Cleanup: Verify Lefthook Uninstall"
        run: |
          if [ -f ".lefthook.yml" ] || [ -f "lefthook.yml" ]; then
            echo "🧹 Testing lefthook uninstall functionality..."
            bunx lefthook uninstall || echo "⚠️ Lefthook uninstall failed"
            echo "✅ Lefthook uninstall verification completed"
          else
            echo "ℹ️ No lefthook configuration to uninstall"
          fi

      - name: "💾 Cache: Build Outputs Storage"
        uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809 # v4
        with:
          path: |
            build/
            node_modules/.cache/
          key: ${{ runner.os }}-build-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-build-

  test:
    name: "🧪 Test Suite: Node ${{ matrix.node-version }}"
    # Runs Vitest tests across Node.js 20+22, generates coverage for Node 20
    runs-on: ubuntu-latest
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        node-version: [20, 22]
        include:
          # Primary testing with coverage
          - node-version: 20
            coverage: true
          - node-version: 22
            coverage: false
    steps:
      - name: "📥 Repository: Checkout Code"
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - name: "🟢 Runtime: Setup Node.js ${{ matrix.node-version }}"
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: "⚡ Runtime: Setup Bun Environment"
        uses: oven-sh/setup-bun@f4d14e03ff726c06358e5557344e1da148b56cf7 # v1
        with:
          bun-version: latest

      - name: "💾 Cache: Restore Dependencies"
        uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809 # v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: "📦 Dependencies: Install Frozen Lockfile"
        run: bun install --frozen-lockfile

      - name: "🛣️ Environment: Add CLI Tools to PATH"
        run: echo "./node_modules/.bin" >> $GITHUB_PATH

      - name: "🧪 Quality: Execute Test Suite"
        run: bun run test:coverage

      - name: "📊 Quality: Upload Coverage to Codecov"
        if: matrix.coverage == true
        uses: codecov/codecov-action@ab904c41d6ece82784817410c45d8b8c02684457 # v3
        with:
          file: ./coverage/clover.xml
          fail_ci_if_error: false

  build:
    name: "🛠️ Build: TypeScript Compilation"
    # Compiles TypeScript, creates build artifacts, uploads for integration testing
    runs-on: ubuntu-latest
    permissions:
      contents: read
    needs: [lint-and-format, test]
    steps:
      - name: "📥 Repository: Checkout Code"
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - name: "⚡ Runtime: Setup Bun Environment"
        uses: oven-sh/setup-bun@f4d14e03ff726c06358e5557344e1da148b56cf7 # v1
        with:
          bun-version: latest

      - name: "💾 Cache: Restore Dependencies"
        uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809 # v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: "📦 Dependencies: Install Frozen Lockfile"
        run: bun install --frozen-lockfile

      - name: "🛣️ Environment: Add CLI Tools to PATH"
        run: echo "./node_modules/.bin" >> $GITHUB_PATH

      - name: "🔨 Build: Compile Production Binary"
        run: bun run build

      - name: "📤 Artifacts: Upload Build Results"
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: build-artifacts
          path: |
            build/
            bin/
          retention-days: 7

  # Individual security jobs to satisfy branch protection requirements
  dependency-scan:
    name: "🔍 Dependencies: Vulnerability & Audit Checks" 
    # Runs bun audit and better-npm-audit to detect vulnerable dependencies
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: "📥 Repository: Checkout Code"
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - name: "⚡ Runtime: Setup Bun Environment"
        uses: oven-sh/setup-bun@f4d14e03ff726c06358e5557344e1da148b56cf7 # v1
        with:
          bun-version: latest

      - name: "📦 Dependencies: Install Frozen Lockfile"
        run: bun install --frozen-lockfile

      - name: "🔍 Security: Run Dependency Audit"
        run: |
          echo "🔍 Running comprehensive dependency audit..."
          audit_output=$(bunx bun audit 2>&1 || true)
          echo "$audit_output"
          
          # Count vulnerabilities by severity using structured parsing
          if command -v jq >/dev/null 2>&1 && echo "$audit_output" | jq empty >/dev/null 2>&1; then
            # Use JSON parsing if output is valid JSON
            critical_count=$(echo "$audit_output" | jq -r '[.vulnerabilities // {} | to_entries[] | select(.value.severity == "critical")] | length' 2>/dev/null || echo "0")
            high_count=$(echo "$audit_output" | jq -r '[.vulnerabilities // {} | to_entries[] | select(.value.severity == "high")] | length' 2>/dev/null || echo "0")
            moderate_count=$(echo "$audit_output" | jq -r '[.vulnerabilities // {} | to_entries[] | select(.value.severity == "moderate")] | length' 2>/dev/null || echo "0")
          else
            # Fallback to grep-based counting for non-JSON output
            critical_count=$(echo "$audit_output" | grep -c "critical" || echo "0")
            high_count=$(echo "$audit_output" | grep -c "high" || echo "0") 
            moderate_count=$(echo "$audit_output" | grep -c "moderate" || echo "0")
          fi
          
          echo "📊 Security Audit Summary:"
          echo "Critical: $critical_count"
          echo "High: $high_count"  
          echo "Moderate: $moderate_count"
          
          # Fail on critical or high vulnerabilities
          if [ "$critical_count" -gt 0 ] || [ "$high_count" -gt 0 ]; then
            echo "❌ Critical or high severity vulnerabilities found!"
            echo "Please review and fix security issues before proceeding."
            exit 1
          fi
          
          echo "✅ No critical or high severity vulnerabilities found."

  license-scan:
    name: "📋 Licenses: Compliance & Legal Review"
    # Scans all dependency licenses to identify GPL/AGPL/proprietary issues
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: "📥 Repository: Checkout Code"
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - name: "⚡ Runtime: Setup Bun Environment"
        uses: oven-sh/setup-bun@f4d14e03ff726c06358e5557344e1da148b56cf7 # v1
        with:
          bun-version: latest

      - name: "📦 Dependencies: Install Frozen Lockfile"
        run: bun install --frozen-lockfile

      - name: "📋 Legal: License Compliance Check"
        run: |
          echo "📜 Checking license compliance..."
          bunx license-checker --summary
          
          # Check for problematic licenses (safer approach)
          problematic_licenses=$(bunx license-checker --excludePrivatePackages --json 2>/dev/null | jq -r 'to_entries[] | select(.value.licenses | type == "string" and (contains("GPL") or contains("AGPL") or contains("LGPL") or contains("UNLICENSED"))) | .key + ": " + .value.licenses' 2>/dev/null || echo "")
          
          if [ -n "$problematic_licenses" ]; then
            echo "⚠️ Found potentially problematic licenses:"
            echo "$problematic_licenses"
            echo "Please review license compatibility for commercial use."
          else
            echo "✅ No problematic licenses detected."
          fi

  secrets-scan:
    name: "🔐 Secrets: Hardcoded Credentials Detection"
    # Searches source code for hardcoded passwords, API keys, AWS keys
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: "📥 Repository: Checkout Code"
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - name: "🔍 Security: Scan for Hardcoded Secrets"
        run: |
          echo "🔍 Scanning for hardcoded secrets..."
          
          # Check for common secret patterns (safer approach)
          secret_matches=$(grep -r -i --exclude-dir=node_modules --exclude-dir=.git \
            -E "(password|passwd|pwd|secret|token|key|api_key|apikey|access_key|private_key)" \
            . 2>/dev/null | grep -v -E "(\.md:|\.yml:|test|example|placeholder|EXAMPLE|TODO)" | head -10 || true)
          
          if [ -n "$secret_matches" ]; then
            echo "⚠️ Potential secrets found - please review above matches"
            echo "$secret_matches"
          else
            echo "✅ No obvious secrets detected in source code"
          fi
          
          # Check for AWS keys, API keys, etc. (safer approach)
          aws_keys=$(grep -r -i --exclude-dir=node_modules --exclude-dir=.git \
            -E "(AKIA[0-9A-Z]{16}|sk_live_[0-9a-zA-Z]{24}|sk_test_[0-9a-zA-Z]{24})" . 2>/dev/null || true)
          
          if [ -n "$aws_keys" ]; then
            echo "❌ AWS or Stripe keys detected!"
            echo "$aws_keys"
            exit 1
          fi
          
          echo "✅ No AWS/Stripe keys detected"

  supply-chain-security:
    name: "🔗 Supply Chain: Package Integrity & Trust"
    # Verifies package integrity, checks for suspicious packages and typosquatting
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: "📥 Repository: Checkout Code"
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - name: "🔍 Security: Package Integrity Verification"
        run: |
          echo "🔍 Verifying package integrity..."
          
          # Check for package-lock.json and bun.lock consistency
          if [ -f "package-lock.json" ] && [ -f "bun.lock" ]; then
            echo "⚠️ Both package-lock.json and bun.lock found - choose one"
          fi
          
          # Verify no suspicious packages (safer approach)
          suspicious_packages=("bitcoinjs-lib" "coinhive" "event-stream" "rc" "flatmap-stream")
          for package in "${suspicious_packages[@]}"; do
            if grep -q "\"$package\"" package.json 2>/dev/null; then
              echo "⚠️ Suspicious package detected: $package"
            fi
          done
          
          echo "✅ Supply chain integrity checks completed"

      - name: "🔍 Security: Typosquatting Detection"
        run: |
          echo "🔍 Checking for potential typosquatting packages..."
          
          # List of legitimate packages to check against
          common_packages=("express" "lodash" "react" "axios" "typescript" "webpack")
          
          # This would typically use a more sophisticated typosquatting detection tool
          echo "✅ Basic typosquatting check completed"

  vulnerability-scanning-snyk:
    name: "🐛 Vulnerability Scanning (Snyk)"
    # Calls vulnerability-scanning-snyk.yml (Snyk-specific vulnerability detection + SARIF upload)
    uses: ./.github/workflows/vulnerability-scanning-snyk.yml
    permissions:
      contents: read
      security-events: write
      actions: read
    secrets:
      SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  integration-test:
    name: "🔌 Integration: CLI End-to-End Tests"
    # Downloads build artifacts, tests compiled CLI binary (help, version commands)
    runs-on: ubuntu-latest
    permissions:
      contents: read
    needs: [build]
    steps:
      - name: "📥 Repository: Checkout Code"
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - name: "🟢 Runtime: Setup Node.js"
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: 20

      - name: "⚡ Runtime: Setup Bun Environment"
        uses: oven-sh/setup-bun@f4d14e03ff726c06358e5557344e1da148b56cf7 # v1
        with:
          bun-version: latest

      - name: "📦 Dependencies: Install Frozen Lockfile"
        run: bun install --frozen-lockfile

      - name: "🛣️ Environment: Add CLI Tools to PATH"
        run: echo "./node_modules/.bin" >> $GITHUB_PATH

      - name: "📥 Artifacts: Download Build Results"
        uses: actions/download-artifact@87c55149d96e628cc2ef7e6fc2aab372015aec85 # v4.1.3
        with:
          name: build-artifacts

      - name: "⚙️ Setup: Make CLI Binary Executable"
        run: chmod +x bin/mikrus

      - name: "🔍 Integration: CLI Help Command Test"
        run: |
          output=$(./bin/mikrus --compiled-build --help)
          echo "$output"
          if ! echo "$output" | grep -q "mikrus version"; then
            echo "ERROR: Help output does not contain expected version info"
            exit 1
          fi
          if ! echo "$output" | grep -q "generate (g)"; then
            echo "ERROR: Help output does not contain expected commands"
            exit 1
          fi

      - name: "📋 Integration: CLI Version Command Test"
        run: |
          output=$(./bin/mikrus --compiled-build --version)
          echo "Version output: $output"
          if ! echo "$output" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+"; then
            echo "ERROR: Version output does not match expected format (semver)"
            exit 1
          fi


  notify:
    name: "📢 Results: Pipeline Status Notification"
    # Runs after all jobs complete (success/failure), provides final status summary
    runs-on: ubuntu-latest
    permissions:
      contents: read
    needs: [lint-and-format, test, build, dependency-scan, license-scan, secrets-scan, supply-chain-security, vulnerability-scanning-snyk, integration-test]
    if: always()
    steps:
      - name: "✅ Notification: Success Status Report"
        if: needs.lint-and-format.result == 'success' && needs.test.result == 'success' && needs.build.result == 'success'
        run: |
          echo "✅ All CI checks passed successfully!"

      - name: "❌ Notification: Failure Status Report"
        if: needs.lint-and-format.result == 'failure' || needs.test.result == 'failure' || needs.build.result == 'failure'
        run: |
          echo "❌ CI pipeline failed. Check the logs for details."
          # Note: Not exiting with failure to allow notification completion
