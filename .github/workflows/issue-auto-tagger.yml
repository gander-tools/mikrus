name: "üè∑Ô∏è AI Issue Auto-Tagger"

on:
  issues:
    types: [opened, edited]

permissions:
  issues: write
  contents: read

jobs:
  auto-tag-issues:
    name: "ü§ñ Analyze and Tag Issues"
    runs-on: ubuntu-latest
    if: github.repository == 'gander-tools/mikrus'
    
    steps:
      - name: "üîç Analyze Issue Content"
        id: analyze
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = issue.body ? issue.body.toLowerCase() : '';
            
            console.log('Issue Title:', issue.title);
            console.log('Issue Body Length:', issue.body ? issue.body.length : 0);
            
            // Initialize labels array
            let labels = [];
            
            // Primary categorization based on title prefix and content
            if (title.includes('[feature]') || title.includes('feature request')) {
              labels.push('feature');
              console.log('‚úÖ Detected FEATURE request');
            } else if (title.includes('[bug]') || title.includes('bug report')) {
              labels.push('bug');
              console.log('‚úÖ Detected BUG report');
            }
            
            // Content-based analysis for additional context
            const contentKeywords = {
              // Priority indicators
              'critical': () => labels.push('priority:critical'),
              'urgent': () => labels.push('priority:high'),
              'blocking': () => labels.push('priority:high'),
              'important': () => labels.push('priority:medium'),
              
              // Component areas
              'cli': () => labels.push('area:cli'),
              'command': () => labels.push('area:cli'),
              'generate': () => labels.push('area:generation'),
              'template': () => labels.push('area:generation'),
              'configuration': () => labels.push('area:config'),
              'config': () => labels.push('area:config'),
              'documentation': () => labels.push('area:docs'),
              'readme': () => labels.push('area:docs'),
              'security': () => labels.push('area:security'),
              'performance': () => labels.push('area:performance'),
              'slow': () => labels.push('area:performance'),
              
              // Bug types
              'crash': () => labels.push('type:crash'),
              'error': () => labels.push('type:error'),
              'exception': () => labels.push('type:error'),
              'memory leak': () => labels.push('type:memory'),
              'regression': () => labels.push('type:regression'),
              
              // Feature types
              'enhancement': () => labels.push('type:enhancement'),
              'improvement': () => labels.push('type:enhancement'),
              'new command': () => labels.push('type:new-feature'),
              'api': () => labels.push('area:api'),
              
              // Complexity indicators
              'simple': () => labels.push('complexity:low'),
              'complex': () => labels.push('complexity:high'),
              'breaking change': () => labels.push('breaking-change'),
              'backward compatibility': () => labels.push('breaking-change'),
              
              // Platform specific
              'windows': () => labels.push('platform:windows'),
              'macos': () => labels.push('platform:macos'),
              'linux': () => labels.push('platform:linux'),
              'node': () => labels.push('runtime:node'),
              'bun': () => labels.push('runtime:bun'),
            };
            
            // Analyze content for keywords
            const fullContent = `${title} ${body}`;
            for (const [keyword, action] of Object.entries(contentKeywords)) {
              if (fullContent.includes(keyword)) {
                action();
                console.log(`üîç Found keyword: "${keyword}"`);
              }
            }
            
            // Special detection patterns
            if (body.includes('steps to reproduce') || body.includes('reproduction')) {
              labels.push('needs-reproduction');
              console.log('üìù Found reproduction steps');
            }
            
            if (body.includes('workaround') && !body.includes('no workaround')) {
              labels.push('has-workaround');
              console.log('üîß Found workaround mentioned');
            }
            
            // Environment detection
            if (body.includes('environment') || body.includes('version')) {
              labels.push('has-environment-info');
              console.log('üñ•Ô∏è Found environment information');
            }
            
            // Remove duplicates and return
            labels = [...new Set(labels)];
            console.log('Final labels:', labels);
            
            return {
              labels: labels,
              shouldTag: labels.length > 0
            };
      
      - name: "üè∑Ô∏è Apply Labels to Issue"
        if: fromJSON(steps.analyze.outputs.result).shouldTag
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
        with:
          script: |
            const result = JSON.parse('${{ steps.analyze.outputs.result }}');
            const labels = result.labels;
            
            if (labels.length === 0) {
              console.log('‚ùå No labels to apply');
              return;
            }
            
            console.log(`üè∑Ô∏è Applying ${labels.length} labels:`, labels);
            
            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: labels
              });
              
              console.log('‚úÖ Labels applied successfully');
              
              // Add a comment explaining the auto-tagging
              const labelList = labels.map(label => `- \`${label}\``).join('\n');
              const comment = 'ü§ñ **Auto-Tagging Complete**\n\n' +
                'This issue has been automatically analyzed and tagged with the following labels:\n' +
                labelList + '\n\n' +
                'These labels help organize and prioritize issues. If any labels seem incorrect, maintainers can adjust them manually.\n\n' +
                '---\n' +
                '*This is an automated process. For questions about auto-tagging, please check the [workflow documentation](https://github.com/' +
                context.repo.owner + '/' + context.repo.repo + '/blob/main/.github/workflows/issue-auto-tagger.yml).*';

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
              
            } catch (error) {
              console.error('‚ùå Error applying labels:', error);
              core.setFailed(`Failed to apply labels: ${error.message}`);
            }

      - name: "üìä Issue Triage Summary"
        if: always()
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
        with:
          script: |
            const issue = context.payload.issue;
            const analyzeResult = '${{ steps.analyze.outputs.result }}';
            const result = analyzeResult ? JSON.parse(analyzeResult) : {};
            
            console.log('=== ISSUE TRIAGE SUMMARY ===');
            console.log(`Issue #${issue.number}: ${issue.title}`);
            console.log(`Author: ${issue.user.login}`);
            console.log(`Labels Applied: ${result.labels ? result.labels.join(', ') : 'none'}`);
            console.log(`Auto-tagging: ${result.shouldTag ? 'SUCCESS' : 'SKIPPED'}`);
            console.log('============================');