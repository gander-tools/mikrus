name: Deployment

on:
  push:
    branches: [main]
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_deploy:
        description: 'Force deployment (skip some checks)'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  deployments: write
  packages: write
  id-token: write

jobs:
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}
    steps:
      - name: Determine deployment environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "release" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ] && [ "${{ github.event_name }}" = "push" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    needs: determine-environment
    if: needs.determine-environment.outputs.should_deploy == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lock') }}

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Add node_modules/.bin to PATH
        run: echo "./node_modules/.bin" >> $GITHUB_PATH

      - name: Run comprehensive tests
        run: |
          echo "üß™ Running comprehensive test suite..."
          bun run test:coverage

      - name: Security audit
        if: ${{ !github.event.inputs.force_deploy }}
        run: |
          echo "üîí Running security audit..."
          audit_output=$(bunx bun audit 2>&1 || true)
          if echo "$audit_output" | grep -E "(critical|high)" -i; then
            echo "‚ùå Security vulnerabilities found!"
            echo "Use force_deploy option to bypass this check."
            exit 1
          fi

      - name: Build verification
        run: |
          echo "üèóÔ∏è Verifying build process..."
          bun run build
          
          # Verify build outputs
          if [ ! -d "build" ]; then
            echo "‚ùå Build directory not found!"
            exit 1
          fi
          
          if [ ! -f "bin/mikrus" ]; then
            echo "‚ùå CLI binary not found!"
            exit 1
          fi

      - name: Integration tests
        run: |
          echo "üîÑ Running integration tests..."
          chmod +x bin/mikrus
          
          # Test CLI help
          output=$(./bin/mikrus --help 2>&1 || true)
          if ! echo "$output" | grep -q "mikrus version"; then
            echo "‚ùå CLI help test failed"
            exit 1
          fi
          
          # Test CLI version
          version_output=$(./bin/mikrus --version 2>&1 || true)
          if ! echo "$version_output" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+"; then
            echo "‚ùå CLI version test failed"
            exit 1
          fi
          
          echo "‚úÖ Integration tests passed"

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [determine-environment, pre-deployment-checks]
    if: needs.determine-environment.outputs.environment == 'staging'
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup deployment
        run: |
          echo "üöÄ Deploying to staging environment..."
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref }}"

      - name: Create deployment artifact
        run: |
          mkdir -p staging-deploy
          cp -r build staging-deploy/ 2>/dev/null || echo "No build directory found"
          cp -r bin staging-deploy/
          cp package.json staging-deploy/
          cp README.md staging-deploy/
          tar -czf staging-deployment.tar.gz staging-deploy/

      - name: Upload staging artifact
        uses: actions/upload-artifact@v4
        with:
          name: staging-deployment
          path: staging-deployment.tar.gz
          retention-days: 30

      - name: Deployment verification
        run: |
          echo "‚úÖ Staging deployment completed successfully!"
          echo "Deployment artifact created and uploaded."

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [determine-environment, pre-deployment-checks]
    if: needs.determine-environment.outputs.environment == 'production'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Add node_modules/.bin to PATH
        run: echo "./node_modules/.bin" >> $GITHUB_PATH

      - name: Production build
        run: |
          echo "üè≠ Creating production build..."
          bun run build

      - name: Create production package
        run: |
          echo "üì¶ Creating production package..."
          mkdir -p production-deploy
          
          # Copy essential files only
          cp -r build production-deploy/
          cp -r bin production-deploy/
          cp package.json production-deploy/
          cp README.md production-deploy/
          cp LICENSE production-deploy/ 2>/dev/null || echo "LICENSE not found, skipping"
          
          # Create versioned archive
          version=$(node -p "require('./package.json').version")
          cd production-deploy && tar -czf ../mikrus-v${version}-production.tar.gz .

      - name: Production deployment simulation
        run: |
          echo "üöÄ Simulating production deployment..."
          echo "This would deploy to production servers/registry"
          
          # In a real scenario, this would:
          # - Upload to production servers
          # - Update load balancers
          # - Run smoke tests
          # - Update monitoring dashboards
          
          echo "‚úÖ Production deployment simulation completed"

      - name: Upload production artifact
        uses: actions/upload-artifact@v4
        with:
          name: production-deployment
          path: mikrus-v*-production.tar.gz
          retention-days: 90

  # Docker deployment (optional)
  deploy-docker:
    name: Deploy Docker Image
    runs-on: ubuntu-latest
    needs: [determine-environment, pre-deployment-checks]
    if: needs.determine-environment.outputs.should_deploy == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create Dockerfile
        run: |
          cat > Dockerfile << 'EOF'
          FROM node:20-alpine AS builder
          
          WORKDIR /app
          COPY package.json bun.lock* ./
          RUN npm install -g bun && bun install --frozen-lockfile
          
          COPY . .
          RUN bun run build
          
          FROM node:20-alpine AS runtime
          
          WORKDIR /app
          COPY --from=builder /app/build ./build
          COPY --from=builder /app/bin ./bin
          COPY --from=builder /app/package.json ./
          COPY --from=builder /app/node_modules ./node_modules
          
          RUN chmod +x bin/mikrus
          
          ENTRYPOINT ["./bin/mikrus"]
          CMD ["--help"]
          EOF

      - name: Build Docker image
        run: |
          docker build -t mikrus:${{ github.sha }} .
          docker tag mikrus:${{ github.sha }} mikrus:latest
          
          # Test the Docker image
          docker run --rm mikrus:latest --version

      - name: Save Docker image
        run: |
          docker save mikrus:latest | gzip > mikrus-docker-image.tar.gz

      - name: Upload Docker artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: mikrus-docker-image.tar.gz
          retention-days: 30

  deployment-notification:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-staging, deploy-production, deploy-docker]
    if: always() && needs.determine-environment.outputs.should_deploy == 'true'
    steps:
      - name: Deployment summary
        run: |
          echo "üéØ Deployment Summary"
          echo "===================="
          echo "Environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "Commit: ${{ github.sha }}"
          echo "Staging: ${{ needs.deploy-staging.result || 'skipped' }}"
          echo "Production: ${{ needs.deploy-production.result || 'skipped' }}"
          echo "Docker: ${{ needs.deploy-docker.result || 'skipped' }}"
          
          if [ "${{ needs.deploy-staging.result }}" = "success" ] || [ "${{ needs.deploy-production.result }}" = "success" ]; then
            echo "‚úÖ Deployment completed successfully!"
          else
            echo "‚ùå Deployment failed or was skipped"
          fi